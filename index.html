<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Argument Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://unpkg.com/compromise"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 700px; margin: auto; padding: 20px; }
        textarea { width: 100%; height: 100px; margin-bottom: 10px; }
        button { padding: 10px 20px; font-size: 16px; }
        #output { margin-top: 20px; padding: 10px; background: #f4f4f4; white-space: pre-line; }
    </style>
</head>
<body>
    <h1>AI Argument Analyzer</h1>
    <textarea id="argumentInput" placeholder="Enter your argument here..."></textarea>
    <button onclick="analyzeArgument()">Analyze</button>
    <div id="output"></div>

    <script>
        async function analyzeArgument() {
            const argument = document.getElementById('argumentInput').value;
            document.getElementById('output').innerText = "Analyzing...";

            let { premises, conclusion } = extractStandardForm(argument);
            let standardForm = `**Standard Form:**\n${premises.join("\n")}\n${conclusion}\n\n`;
            let logicalForm = convertToLogicalForm(standardForm);
            let validity = checkValidity(logicalForm);
            let fallacies = detectFallacies(logicalForm);
            let aiAnalysis = await analyzeWithAI(argument);

            let analysis = `${standardForm}**Logical Form:**\n${logicalForm}\n\n`;
            analysis += `Validity: ${validity}\n`;
            analysis += `Fallacies Detected: ${fallacies.join(", ") || "None detected"}\n`;
            analysis += `AI Analysis: ${aiAnalysis}`;

            document.getElementById('output').innerText = analysis;
        }

        function extractStandardForm(argument) {
            const doc = nlp(argument);
            const sentences = doc.sentences().out('array');
            let premises = [];
            let conclusion = "";

            sentences.forEach((sentence, index) => {
                if (sentence.match(/(therefore|thus|hence|so)/i)) {
                    conclusion = "Conclusion: " + sentence.replace(/(therefore|thus|hence|so)/i, "").trim();
                } else {
                    premises.push(`P${index + 1}: ${sentence}`);
                }
            });

            if (!conclusion && premises.length > 1) {
                conclusion = "Conclusion: " + premises.pop();
            } else if (!conclusion) {
                conclusion = "Conclusion: [Not Explicitly Stated]";
            }

            return { premises, conclusion };
        }

        function convertToLogicalForm(standardForm) {
            return standardForm.replace(/if /gi, "P → ")
                               .replace(/then /gi, "Q")
                               .replace(/or /gi, " ∨ ")
                               .replace(/not /gi, "¬");
        }

        function checkValidity(logicalForm) {
            if (logicalForm.includes("P → Q") && logicalForm.includes("P") && logicalForm.includes("∴ Q")) {
                return "✓ This argument follows Modus Ponens and is valid.";
            }
            if (logicalForm.includes("P → Q") && logicalForm.includes("¬Q") && logicalForm.includes("∴ ¬P")) {
                return "✓ This argument follows Modus Tollens and is valid.";
            }
            if (logicalForm.includes("P → Q") && logicalForm.includes("Q → R") && logicalForm.includes("∴ P → R")) {
                return "✓ This argument follows Hypothetical Syllogism and is valid.";
            }
            if (logicalForm.includes("P ∨ Q") && logicalForm.includes("¬P") && logicalForm.includes("∴ Q")) {
                return "✓ This argument follows Disjunctive Syllogism and is valid.";
            }
            return "X This argument is invalid. The conclusion does not logically follow from the premises.";
        }

        function detectFallacies(logicalForm) {
            const fallacies = [];
            if (logicalForm.includes("P → Q") && logicalForm.includes("Q") && logicalForm.includes("∴ P")) {
                fallacies.push("Affirming the Consequent");
            }
            if (logicalForm.includes("P → Q") && logicalForm.includes("¬P") && logicalForm.includes("∴ ¬Q")) {
                fallacies.push("Denying the Antecedent");
            }
            if (logicalForm.includes("All A are C") && logicalForm.includes("All B are C") && logicalForm.includes("∴ All A are B")) {
                fallacies.push("Undistributed Middle");
            }
            return fallacies;
        }

        async function analyzeWithAI(argument) {
            const model = await loadAIModel();
            const vector = tf.tensor2d([textToVector(argument)]);
            const prediction = model.predict(vector);
            const result = await prediction.data();
            return result[0] > result[1] ? "✓ AI Analysis: This argument is likely valid." : "X AI Analysis: This argument is likely invalid.";
        }

        async function loadAIModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({ inputShape: [50], units: 32, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 2, activation: 'softmax' }));

            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        function textToVector(text) {
            let vector = new Array(50).fill(0);
            const words = text.toLowerCase().split(" ");
            words.forEach((word, index) => {
                if (index < 50) {
                    vector[index] = word.length;
                }
            });
            return vector;
        }
    </script>
</body>
</html>
